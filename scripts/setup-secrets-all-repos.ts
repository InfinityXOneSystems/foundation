#!/usr/bin/env node
// scripts/setup-secrets-all-repos.ts
// Master setup script for configuring encryption, gitignore, and secrets sync
// across all InfinityXOneSystems repositories
// Supports: --once (default), --daemon, --discover, --status

import * as fs from "fs";
import * as path from "path";
import * as crypto from "crypto";
import { GitHubRepoDiscovery, Repository } from "../src/services/github-repo-discovery";
import { SecretsSyncDaemon } from "../src/services/secrets-sync-daemon";

const REPOS_ROOT = process.env.REPOS_ROOT || path.join(process.env.HOME || process.env.USERPROFILE || "~", "Documents/InfinityXOneSystems");
const REPOS = ["foundation", "frontend", "backend", "ai-orchestrator"]; // Fallback hardcoded list
const CONFIG_PATH = path.join(__dirname, "../config/secrets-sync.config.json");

interface SecretConfig {
  repoName: string;
  hasNodeProject: boolean;
  hasPythonProject: boolean;
  hasGoogleCloud: boolean;
  hasDocker: boolean;
}

interface SetupResult {
  repo: string;
  status: "success" | "failed";
  message: string;
  secretsCount?: number;
}

interface SyncConfig {
  github: {
    organization: string;
    token_env_var: string;
  };
  sync: {
    enabled: boolean;
    interval_hours: number;
    auto_start: boolean;
  };
  repos: {
    exclude: string[];
    include_archived: boolean;
    include_private: boolean;
  };
  secrets: {
    encryption_key_length: number;
    auto_rotate_keys: boolean;
  };
}

// Command-line arguments
const args = process.argv.slice(2);
const mode = args.find((arg) => arg.startsWith("--"))?.toLowerCase() || "--once";

// Log header
function logHeader() {
  console.log("üîê Infinity X One Systems - Master Secrets Setup");
  console.log("================================================\n");
}

/**
 * Load configuration
 */
function loadConfig(): SyncConfig {
  try {
    if (fs.existsSync(CONFIG_PATH)) {
      return JSON.parse(fs.readFileSync(CONFIG_PATH, "utf-8"));
    }
  } catch (error) {
    console.debug("Failed to load config, using defaults:", error);
  }

  // Return default config
  return {
    github: {
      organization: "InfinityXOneSystems",
      token_env_var: "GITHUB_TOKEN",
    },
    sync: {
      enabled: true,
      interval_hours: 6,
      auto_start: true,
    },
    repos: {
      exclude: [],
      include_archived: false,
      include_private: true,
    },
    secrets: {
      encryption_key_length: 32,
      auto_rotate_keys: false,
    },
  };
}

/**
 * Get GitHub token from environment
 */
function getGitHubToken(config: SyncConfig): string | null {
  const token = process.env[config.github.token_env_var];
  if (!token) {
    console.warn(`‚ö†Ô∏è  ${config.github.token_env_var} not set in environment`);
    return null;
  }
  return token;
}

/**
 * Discover repositories from GitHub
 */
async function discoverRepositories(config: SyncConfig, forceRefresh = false): Promise<string[]> {
  const token = getGitHubToken(config);
  
  if (!token) {
    console.log("‚ö†Ô∏è  GitHub token not available, using fallback hardcoded list");
    return REPOS;
  }

  try {
    const discovery = new GitHubRepoDiscovery(token, {
      organization: config.github.organization,
      includeArchived: config.repos.include_archived,
      includePrivate: config.repos.include_private,
      excludeRepos: config.repos.exclude,
    });

    await discovery.checkRateLimit();
    const repos = await discovery.discoverRepositories(forceRefresh);
    
    return repos.map((repo) => repo.name);
  } catch (error) {
    console.error("‚ùå Failed to discover repositories:", error);
    console.log("‚ö†Ô∏è  Falling back to hardcoded repository list");
    return REPOS;
  }
}

/**
 * Generate cryptographically secure encryption key
 */
function generateEncryptionKey(length = 32): string {
  return crypto.randomBytes(length).toString("base64");
}

/**
 * Detect project type and required secrets
 */
function detectProjectConfig(repoPath: string): SecretConfig {
  return {
    repoName: path.basename(repoPath),
    hasNodeProject: fs.existsSync(path.join(repoPath, "package.json")),
    hasPythonProject: fs.existsSync(path.join(repoPath, "requirements.txt")) || fs.existsSync(path.join(repoPath, "Pipfile")),
    hasGoogleCloud: fs.existsSync(path.join(repoPath, "src")) && fs.existsSync(path.join(repoPath, "config")),
    hasDocker: fs.existsSync(path.join(repoPath, "Dockerfile")) || fs.existsSync(path.join(repoPath, "docker-compose.yml")),
  };
}

/**
 * Create comprehensive .gitignore for repository type
 */
function createGitignore(repoPath: string, config: SecretConfig): boolean {
  const gitignorePath = path.join(repoPath, ".gitignore");
  
  let content = `# Auto-generated by master secrets setup script
# ============================================================
# DO NOT MODIFY - Use setup-secrets-all-repos.ts to regenerate
# ============================================================

`;

  // Base ignores
  content += `# Environment & Secrets (NEVER COMMIT)
.env
.env.local
.env.*.local
.env.production.local
.env.development.local
.env.test.local
*.env
*.key
*.pem
*.p12
*.token
secrets.json
credentials.json
google-service-account.json

`;

  // Node.js ignores
  if (config.hasNodeProject) {
    content += `# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json
yarn.lock
pnpm-lock.yaml
.npm
.eslintcache

`;
  }

  // Python ignores
  if (config.hasPythonProject) {
    content += `# Python
venv/
env/
ENV/
.venv
__pycache__/
*.py[cod]
*.egg-info/
dist/
build/
*.egg
.Python

`;
  }

  // Build output
  content += `# Build & Compilation
/dist/
/build/
/out/
/.next/
/.vercel/
/.output/
coverage/
.tsbuildinfo

# IDE
.vscode/
.idea/
*.code-workspace
.DS_Store
Thumbs.db

# OS & Temp
*.tmp
*.bak
*.log*
.cache/

`;

  try {
    fs.writeFileSync(gitignorePath, content);
    return true;
  } catch (error: unknown) {
    console.debug(`Failed to write gitignore: ${error instanceof Error ? error.message : "Unknown error"}`);
    return false;
  }
}

/**
 * Create .env.local template for repository
 */
function createEnvLocalTemplate(repoPath: string, config: SecretConfig): boolean {
  const envPath = path.join(repoPath, ".env.local");
  
  // Skip if already exists
  if (fs.existsSync(envPath)) {
    return true;
  }

  let content = `# Local environment variables - NEVER COMMIT
# Generated by master secrets setup - ${new Date().toISOString()}
#
# ============================================================
# REQUIRED: ENCRYPTION & MOBILE ACCESS
# ============================================================
ENCRYPTION_KEY=${generateEncryptionKey()}
ADMIN_KEY=${generateEncryptionKey()}

`;

  // Node.js specific
  if (config.hasNodeProject) {
    content += `# ============================================================
# NODE.JS CONFIGURATION
# ============================================================
PORT=3000
NODE_ENV=development
JWT_SECRET=${crypto.randomBytes(32).toString("hex")}

`;
  }

  // Google Cloud
  if (config.hasGoogleCloud) {
    content += `# ============================================================
# GOOGLE CLOUD CONFIGURATION
# ============================================================
GOOGLE_CLOUD_PROJECT_ID=<your-project-id>
GOOGLE_CLIENT_ID=<your-client-id>.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=GOCSPX-xxxxxxxxxxxxxxxxxxxxx
GOOGLE_SERVICE_ACCOUNT_KEY_PATH=./config/google-service-account.json

`;
  }

  // GitHub secrets
  content += `# ============================================================
# GITHUB CONFIGURATION
# ============================================================
GITHUB_TOKEN=your-github-token-here
GITHUB_REPO=InfinityXOneSystems/${config.repoName}

`;

  // API Keys section
  content += `# ============================================================
# API KEYS (Paste your keys here)
# ============================================================
GROQ_API_KEY=
ANTHROPIC_API_KEY=
OPENAI_API_KEY=

`;

  try {
    fs.writeFileSync(envPath, content);
    return true;
  } catch (error: unknown) {
    console.debug(`Failed to write .env.local: ${error instanceof Error ? error.message : "Unknown error"}`);
    return false;
  }
}

/**
 * Create secrets manifest template
 */
function createSecretsManifestTemplate(repoPath: string): boolean {
  const manifestPath = path.join(repoPath, "secrets-manifest.json");

  const manifest = {
    version: "1.0.0",
    generatedAt: new Date().toISOString(),
    repository: path.basename(repoPath),
    secrets: {
      encryption: {
        ENCRYPTION_KEY: "AES-256-CBC encryption key",
        ADMIN_KEY: "Admin key for token generation",
      },
      github: {
        GITHUB_TOKEN: "GitHub Personal Access Token",
        GITHUB_REPO: "GitHub repository (owner/repo)",
      },
      google: {
        GOOGLE_CLOUD_PROJECT_ID: "Google Cloud project ID",
        GOOGLE_CLIENT_ID: "Google OAuth client ID",
        GOOGLE_CLIENT_SECRET: "Google OAuth client secret",
      },
      apis: {
        GROQ_API_KEY: "Groq API key",
        ANTHROPIC_API_KEY: "Anthropic/Claude API key",
        OPENAI_API_KEY: "OpenAI API key",
      },
    },
    syncStatus: {
      lastSync: new Date().toISOString(),
      synced: false,
      githubSecretsCount: 0,
    },
  };

  try {
    fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
    return true;
  } catch (error: unknown) {
    console.debug(`Failed to write manifest: ${error instanceof Error ? error.message : "Unknown error"}`);
    return false;
  }
}

/**
 * Process single repository
 */
function setupRepository(repoPath: string): SetupResult {
  if (!fs.existsSync(repoPath)) {
    return {
      repo: path.basename(repoPath),
      status: "failed",
      message: `Repository not found: ${repoPath}`,
    };
  }

  const config = detectProjectConfig(repoPath);
  const results: string[] = [];

  // Create .gitignore
  if (createGitignore(repoPath, config)) {
    results.push("‚úÖ .gitignore created");
  } else {
    results.push("‚ö†Ô∏è  .gitignore update failed");
  }

  // Create .env.local template
  if (createEnvLocalTemplate(repoPath, config)) {
    results.push("‚úÖ .env.local template created");
  } else {
    results.push("‚ö†Ô∏è  .env.local creation failed");
  }

  // Create secrets manifest
  if (createSecretsManifestTemplate(repoPath)) {
    results.push("‚úÖ secrets-manifest.json created");
  } else {
    results.push("‚ö†Ô∏è  secrets manifest creation failed");
  }

  return {
    repo: config.repoName,
    status: "success",
    message: results.join(" | "),
    secretsCount: Object.keys(config).filter(k => (config as unknown as Record<string, unknown>)[k]).length,
  };
}

/**
 * Main execution
 */
async function main() {
  logHeader();
  
  const config = loadConfig();

  // Handle different modes
  switch (mode) {
    case "--discover":
      await handleDiscoverMode(config);
      break;
    case "--status":
      await handleStatusMode();
      break;
    case "--daemon":
      await handleDaemonMode(config);
      break;
    case "--once":
    default:
      await handleOnceMode(config);
      break;
  }
}

/**
 * Handle discover mode - list all repositories
 */
async function handleDiscoverMode(config: SyncConfig) {
  console.log("üîç DISCOVERY MODE - Listing all repositories\n");
  
  const repos = await discoverRepositories(config, true);
  
  console.log(`\nüìã DISCOVERED REPOSITORIES (${repos.length} total):`);
  console.log("================================================");
  repos.forEach((repo, index) => {
    console.log(`${(index + 1).toString().padStart(3)}. ${repo}`);
  });
  console.log();
}

/**
 * Handle status mode - show sync status
 */
async function handleStatusMode() {
  console.log("üìä SYNC STATUS REPORT\n");
  
  const status = SecretsSyncDaemon.getStatus();
  const isRunning = SecretsSyncDaemon.isRunning();
  
  console.log(`Daemon Status: ${isRunning ? "üü¢ RUNNING" : "üî¥ STOPPED"}`);
  
  if (status) {
    console.log(`Last Sync: ${status.lastSync || "Never"}`);
    console.log(`Next Sync: ${status.nextSync || "N/A"}`);
    console.log(`Success Count: ${status.successCount}`);
    console.log(`Failure Count: ${status.failureCount}`);
    console.log();
    
    const repoCount = Object.keys(status.repositories).length;
    if (repoCount > 0) {
      console.log(`üìÅ Repository Status (${repoCount} repos):`);
      console.log("================================================");
      
      for (const [repo, repoStatus] of Object.entries(status.repositories)) {
        const icon = repoStatus.status === "success" ? "‚úÖ" : "‚ùå";
        console.log(`${icon} ${repo}: ${repoStatus.message}`);
      }
    }
  } else {
    console.log("No sync status available yet.");
  }
  console.log();
}

/**
 * Handle daemon mode - continuous operation
 */
async function handleDaemonMode(config: SyncConfig) {
  console.log("üîÑ DAEMON MODE - Continuous 24/7 Operation\n");
  
  if (!config.sync.enabled) {
    console.error("‚ùå Sync is disabled in configuration");
    process.exit(1);
  }

  const daemon = new SecretsSyncDaemon(
    {
      intervalHours: config.sync.interval_hours,
      enabled: config.sync.enabled,
      autoStart: config.sync.auto_start,
    },
    async () => {
      // Sync function - run the setup for all repos
      const result = await runSetupForAllRepos(config);
      return {
        success: result.successCount > 0,
        message: `Synced ${result.successCount} repos (${result.failureCount} failed)`,
      };
    }
  );

  await daemon.start();
  
  // Keep process alive indefinitely - daemon will exit on SIGINT/SIGTERM
  await new Promise<never>(() => {}); // Intentional: infinite wait for signal
}

/**
 * Handle once mode - single execution (original behavior)
 */
async function handleOnceMode(config: SyncConfig) {
  console.log("‚ö° ONCE MODE - Single Execution\n");
  
  const result = await runSetupForAllRepos(config);
  
  // Summary
  console.log("üìä SETUP SUMMARY");
  console.log("================================================");
  console.log(`Total repositories: ${result.totalCount}`);
  console.log(`Successful: ${result.successCount}`);
  console.log(`Failed: ${result.failureCount}`);
  console.log();

  console.log("üöÄ NEXT STEPS:");
  console.log("1. Edit .env.local in each repository with your actual secrets");
  console.log("2. Run: npm run sync:secrets:push (to push to GitHub)");
  console.log("3. Verify: npm run sync:secrets:mobile my-device");
  console.log("4. Start: npm run api:mobile (to start mobile API)");
  console.log();

  console.log("üìã WHAT WAS CREATED:");
  console.log("  ‚Ä¢ .gitignore (comprehensive secret protection)");
  console.log("  ‚Ä¢ .env.local (template with encryption keys)");
  console.log("  ‚Ä¢ secrets-manifest.json (audit & documentation)");
  console.log();

  console.log("üîí SECURITY CHECKLIST:");
  console.log("  ‚òê Review .env.local values");
  console.log("  ‚òê Replace template values with real credentials");
  console.log("  ‚òê Never commit .env.local files");
  console.log("  ‚òê Verify .gitignore is in root of each repo");
  console.log("  ‚òê Run git check-ignore .env.local");
  console.log("  ‚òê Push secrets to GitHub via sync:secrets:push");
  console.log();
}

/**
 * Run setup for all repositories
 */
async function runSetupForAllRepos(config: SyncConfig): Promise<{
  totalCount: number;
  successCount: number;
  failureCount: number;
  results: SetupResult[];
}> {
  const repos = await discoverRepositories(config);
  
  console.log(`üìÅ Repository Root: ${REPOS_ROOT}`);
  console.log(`üìã Processing ${repos.length} repositories...\n`);

  const setupResults: SetupResult[] = [];

  for (const repo of repos) {
    const repoPath = path.join(REPOS_ROOT, repo);
    console.log(`Processing: ${repo}...`);
    
    const result = setupRepository(repoPath);
    setupResults.push(result);
    
    console.log(`  ${result.message}`);
    if (result.status === "failed") {
      console.log(`  ‚ùå Error: ${result.message}`);
    }
    console.log();
  }

  return {
    totalCount: setupResults.length,
    successCount: setupResults.filter((r) => r.status === "success").length,
    failureCount: setupResults.filter((r) => r.status === "failed").length,
    results: setupResults,
  };
}

/**
 * Main execution wrapper
 */
main().catch(err => {
  console.error("‚ùå Setup failed:", err);
  process.exit(1);
});
